version: 0.2

phases:
  install:
    runtime-versions:
      python: 3.11
    commands:
      - echo "Installing dependencies..."
      # postgresql client is required for croft database IAM authentication bootstrap
      # See: croft/tf/modules/croft_base/README.md for details
      - yum install -y git jq postgresql17
      # Install OpenTofu
      - |
        echo "Installing OpenTofu version ${OPENTOFU_VERSION}"
        curl -L https://github.com/opentofu/opentofu/releases/download/v${OPENTOFU_VERSION}/tofu_${OPENTOFU_VERSION}_linux_arm64.zip -o tofu.zip
        unzip tofu.zip
        mv tofu /usr/local/bin/
        rm tofu.zip
        chmod +x /usr/local/bin/tofu
        tofu --version

  pre_build:
    commands:
      - echo "Setting up terraform plugin cache..."
      - export TF_PLUGIN_CACHE_DIR="$HOME/.terraform.d/plugin-cache"
      - mkdir -p $TF_PLUGIN_CACHE_DIR
      - echo "Loading sensitive parameters from SSM..."
      - |
        if [ ! -z "$PARAMETER_STORE_PREFIX" ]; then
          # Get all parameters and export as TF_VAR_ environment variables
          aws ssm get-parameters-by-path \
            --path "$PARAMETER_STORE_PREFIX" \
            --recursive \
            --with-decryption \
            --query 'Parameters[*].[Name,Value]' \
            --output text > /tmp/ssm_params.txt
          
          # Create env file even if empty to avoid source error
          touch /tmp/env_vars.sh
          
          # Now source them in the main shell
          while IFS=$'\t' read -r name value; do
            var_name=$(echo $name | sed "s|$PARAMETER_STORE_PREFIX/||" | sed 's/^/TF_VAR_/')
            export "$var_name=$value"
            echo "export $var_name='$value'" >> /tmp/env_vars.sh
            echo "Loaded parameter: $var_name"
          done < /tmp/ssm_params.txt
          
          # Source the environment variables file
          source /tmp/env_vars.sh
        fi
      
      # Extract metadata from the source artifact
      - |
        if [ -f metadata.json ]; then
          echo "Found metadata.json:"
          cat metadata.json
          export COMMIT_SHA=$(jq -r '.commit_sha' metadata.json)
          export BRANCH=$(jq -r '.branch' metadata.json)
          export AUTHOR=$(jq -r '.author' metadata.json)
        fi

  build:
    commands:
      - echo "Running terraform apply for environment ${ENVIRONMENT}..."
      
      # Source the environment variables if they exist
      - |
        if [ -f /tmp/env_vars.sh ]; then
          echo "Sourcing environment variables..."
          source /tmp/env_vars.sh
        fi
      
      # Look for plan artifact directory (contains plan file + .terraform modules)
      - |
        echo "Looking for plan artifact from plan stage..."
        PLAN_ARTIFACT_DIR=""

        # When CodePipeline passes multiple artifacts, it creates CODEBUILD_SRC_DIR_<artifact_name> variables
        for var in $(env | grep "^CODEBUILD_SRC_DIR_" | cut -d= -f1); do
          dir="${!var}"
          echo "Checking artifact directory: $var = $dir"
          if [ -f "$dir/$ROOT_MODULE_DIR/tfplan" ]; then
            echo "Found tfplan in $dir/$ROOT_MODULE_DIR/"
            PLAN_ARTIFACT_DIR="$dir"
            break
          fi
        done

        if [ -z "$PLAN_ARTIFACT_DIR" ]; then
          echo "ERROR: No plan file found from plan stage!"
          echo "This apply project requires a pre-existing plan."
          echo "FAILED" > build_status.txt
          exit 1
        fi

      # Copy .terraform directory, lock file, and plan from artifact
      - |
        cd $ROOT_MODULE_DIR
        echo "Copying .terraform directory and lock file from plan artifact..."

        # Copy .terraform directory if present (contains modules and state)
        if [ -d "$PLAN_ARTIFACT_DIR/$ROOT_MODULE_DIR/.terraform" ]; then
          cp -r "$PLAN_ARTIFACT_DIR/$ROOT_MODULE_DIR/.terraform" .
          echo ".terraform directory copied successfully"
        fi

        # Copy the lock file to ensure consistent provider versions
        if [ -f "$PLAN_ARTIFACT_DIR/$ROOT_MODULE_DIR/.terraform.lock.hcl" ]; then
          cp "$PLAN_ARTIFACT_DIR/$ROOT_MODULE_DIR/.terraform.lock.hcl" .
          echo ".terraform.lock.hcl copied successfully"
        else
          echo "ERROR: .terraform.lock.hcl not found in plan artifact"
          exit 1
        fi

        echo "Copying plan file..."
        cp "$PLAN_ARTIFACT_DIR/$ROOT_MODULE_DIR/tfplan" tfplan
        echo "Plan file copied successfully"

      # Run tofu init to download providers (modules already present from copied .terraform)
      - |
        cd $ROOT_MODULE_DIR
        echo "Running tofu init to download providers..."
        echo "Lock file ensures we use the same provider versions as the plan"
        tofu init -input=false
        echo "Init complete - providers downloaded"
      
      # Run terraform apply using the existing plan
      - |
        echo "Running tofu apply with existing plan..."
        echo "---------------------------------------"
        echo "---------------------------------------"
        echo "---------------------------------------"
        echo "-------------Begin Apply---------------"
        echo "---------------------------------------"
        if tofu apply -input=false tfplan 2>&1 | tee apply_full.log; then
          echo "Terraform apply succeeded"
          echo "SUCCESS" > build_status.txt
          # Extract just the summary line for reporting
          grep "Apply complete!" apply_full.log > apply_output.txt || echo "No apply summary found" > apply_output.txt
        else
          echo "Terraform apply failed"
          echo "FAILED" > build_status.txt
          echo "Terraform apply failed" > apply_output.txt
          exit 1
        fi
        echo "---------------------------------------"
        echo "--------------End Apply----------------"
        echo "---------------------------------------"
        echo "---------------------------------------"
        echo "---------------------------------------"

  post_build:
    commands:
      - |
        echo "Creating apply summary..."
        BUILD_SUCCESS="true"
        if [ -f "build_status.txt" ] && [ "$(cat build_status.txt)" = "FAILED" ]; then
          BUILD_SUCCESS="false"
        fi
        
        # For apply operations, extract the actual changes that were applied
        if [ -f "apply_output.txt" ] && [ "$BUILD_SUCCESS" = "true" ]; then
          # Parse apply output to count actual changes
          # Look for lines like "Apply complete! Resources: 2 added, 1 changed, 0 destroyed."
          APPLY_SUMMARY=$(grep "Apply complete!" apply_output.txt || echo "")
          if [ ! -z "$APPLY_SUMMARY" ]; then
            # Extract numbers using regex (use [0-9]+ to match one or more digits, head -1 to get first match)
            ADDED=$(echo "$APPLY_SUMMARY" | grep -o '[0-9]\+ added' | grep -o '[0-9]\+' | head -1 || echo "0")
            CHANGED=$(echo "$APPLY_SUMMARY" | grep -o '[0-9]\+ changed' | grep -o '[0-9]\+' | head -1 || echo "0")
            DESTROYED=$(echo "$APPLY_SUMMARY" | grep -o '[0-9]\+ destroyed' | grep -o '[0-9]\+' | head -1 || echo "0")

            # Ensure variables have values (fallback to 0 if empty)
            ADDED=${ADDED:-0}
            CHANGED=${CHANGED:-0}
            DESTROYED=${DESTROYED:-0}

            echo "{\"create\": $ADDED, \"update\": $CHANGED, \"delete\": $DESTROYED}" > counts.json
          else
            echo '{"create": 0, "update": 0, "delete": 0}' > counts.json
          fi
        else
          echo '{"create": 0, "update": 0, "delete": 0}' > counts.json
        fi
        
        # Create summary with actual applied counts
        jq -n --argjson counts "$(cat counts.json)" \
              --arg env "$ENVIRONMENT" \
              --arg commit_sha "${COMMIT_SHA:-unknown}" \
              --arg branch "${BRANCH:-unknown}" \
              --arg author "${AUTHOR:-unknown}" \
              --argjson success $BUILD_SUCCESS \
              --arg build_id "$CODEBUILD_BUILD_ID" \
              --arg apply_output "$(cat apply_output.txt 2>/dev/null || echo "No apply output")" \
              '{
                env: $env,
                commit_sha: $commit_sha,
                branch: $branch,
                author: $author,
                success: $success,
                build_id: $build_id,
                create: ($counts.create // 0),
                update: ($counts.update // 0),
                delete: ($counts.delete // 0),
                apply_output: $apply_output,
                operation: "apply"
              }' > "hoist_summary_${ENVIRONMENT}.json"
      
      - echo "Apply completed"

artifacts:
  files:
    - '**/*'
  name: apply-output
